<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[网络监控]]></title>
    <url>%2F2018%2F12%2F25%2Flinux%2Fiftop%2F</url>
    <content type="text"><![CDATA[iftopTX：发送流量RX：接收流量TOTAL：总流量Cumm：运行iftop到目前时间的总流量peak：流量峰值rates：分别表示过去 2s 10s 40s 的平均流量 按h切换是否显示帮助; 按n切换显示本机的IP或主机名; 按s切换是否显示本机的host信息; 按d切换是否显示远端目标主机的host信息; 按t切换显示格式为2行/1行/只显示发送流量/只显示接收流量; 按N切换显示端口号或端口服务名称; 按S切换是否显示本机的端口信息; 按D切换是否显示远端目标主机的端口信息; 按p切换是否显示端口信息; 按P切换暂停/继续显示; 按b切换是否显示平均流量图形条; 按B切换计算2秒或10秒或40秒内的平均流量; 按T切换是否显示每个连接的总流量; 按l打开屏幕过滤功能，输入要过滤的字符，比如ip,按回车后，屏幕就只显示这个IP相关的流量信息; 按L切换显示画面上边的刻度;刻度不同，流量图形条会有变化; 按j或按k可以向上或向下滚动屏幕显示的连接记录; 按1或2或3可以根据右侧显示的三列流量数据进行排序; 按&lt;根据左边的本机名或IP排序; 按&gt;根据远端目标主机的主机名或IP排序; 按o切换是否固定只显示当前的连接; 按f可以编辑过滤代码，这是翻译过来的说法，我还没用过这个！ 按!可以使用shell命令，这个没用过！没搞明白啥命令在这好用呢！ 按q退出监控。 常用：t p n]]></content>
      <categories>
        <category>Linux</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[内核调优]]></title>
    <url>%2F2018%2F12%2F24%2Flinux%2F%E5%86%85%E6%A0%B8%E8%B0%83%E4%BC%98sysctl.conf%2F</url>
    <content type="text"><![CDATA[内核调优sysctl.confnet.ipv4.tcp_syncookies = 1表示开启SYN Cookies。当出现SYN等待队列溢出时，启用cookies来处理，可防范少量SYN攻击，默认为0，表示关闭； net.ipv4.tcp_tw_reuse = 1表示开启重用。允许将TIME-WAIT sockets重新用于新的TCP连接，默认为0，表示关闭； net.ipv4.tcp_tw_recycle = 1表示开启TCP连接中TIME-WAIT sockets的快速回收，默认为0，表示关闭； net.ipv4.tcp_fin_timeout = 30修改系統默认的 TIMEOUT 时间 net.ipv4.tcp_keepalive_time = 1200表示当keepalive起用的时候，TCP发送keepalive消息的频度。缺省是2小时，改为20分钟。 net.ipv4.ip_local_port_range = 10000 65000表示用于向外连接的端口范围。缺省情况下很小：32768到61000，改为10000到65000。（注意：这里不要将最低值设的太低，否则可能会占用掉正常的端口！） net.ipv4.tcp_max_syn_backlog = 8192表示SYN队列的长度，默认为1024，加大队列长度为8192，可以容纳更多等待连接的网络连接数。 net.ipv4.tcp_max_tw_buckets = 6000表示系统同时保持TIME_WAIT的最大数量，如果超过这个数字，TIME_WAIT将立刻被清除并打印警告信息。默 认为180000，改为6000。对于Apache、Nginx等服务器，上几行的参数可以很好地减少TIME_WAIT套接字数量，但是对于Squid，效果却不大。此项参数可以控制TIME_WAIT的最大数量，避免Squid服务器被大量的TIME_WAIT拖死。 net.ipv4.tcp_max_syn_backlog = 65536记录的那些尚未收到客户端确认信息的连接请求的最大值。对于有128M内存的系统而言，缺省值是1024，小内存的系统则是128。 net.core.netdev_max_backlog = 32768每个网络接口接收数据包的速率比内核处理这些包的速率快时，允许送到队列的数据包的最大数目。 net.core.somaxconn = 32768web应用中listen函数的backlog默认会给我们内核参数的net.core.somaxconn限制到128，而nginx定义的NGX_LISTEN_BACKLOG默认为511，所以有必要调整这个值。 net.core.wmem_default = 8388608net.core.rmem_default = 8388608net.core.rmem_max = 16777216 最大socket读buffer,可参考的优化值:873200net.core.wmem_max = 16777216 最大socket写buffer,可参考的优化值:873200net.ipv4.tcp_timestsmps = 0时间戳可以避免序列号的卷绕。一个1Gbps的链路肯定会遇到以前用过的序列号。时间戳能够让内核接受这种“异常”的数据包。这里需要将其关掉。 net.ipv4.tcp_synack_retries = 2为了打开对端的连接，内核需要发送一个SYN并附带一个回应前面一个SYN的ACK。也就是所谓三次握手中的第二次握手。这个设置决定了内核放弃连接之前发送SYN+ACK包的数量。 net.ipv4.tcp_syn_retries = 2在内核放弃建立连接之前发送SYN包的数量。 #net.ipv4.tcp_tw_len = 1net.ipv4.tcp_tw_reuse = 1 开启重用。允许将TIME-WAIT sockets重新用于新的TCP连接。 net.ipv4.tcp_wmem = 8192 436600 873200TCP写buffer,可参考的优化值: 8192 436600 873200 net.ipv4.tcp_rmem = 32768 436600 873200TCP读buffer,可参考的优化值: 32768 436600 873200 net.ipv4.tcp_mem = 94500000 91500000 92700000 同样有3个值,意思是:net.ipv4.tcp_mem[0]:低于此值，TCP没有内存压力。net.ipv4.tcp_mem[1]:在此值下，进入内存压力阶段。net.ipv4.tcp_mem[2]:高于此值，TCP拒绝分配socket。上述内存单位是页，而不是字节。可参考的优化值是:786432 1048576 1572864 net.ipv4.tcp_max_orphans = 3276800系统中最多有多少个TCP套接字不被关联到任何一个用户文件句柄上。如果超过这个数字，连接将即刻被复位并打印出警告信息。这个限制仅仅是为了防止简单的DoS攻击，不能过分依靠它或者人为地减小这个值，更应该增加这个值(如果增加了内存之后)。 net.ipv4.tcp_fin_timeout = 30如果套接字由本端要求关闭，这个参数决定了它保持在FIN-WAIT-2状态的时间。对端可以出错并永远不关闭连接，甚至意外当机。缺省值是60秒。2.2 内核的通常值是180秒，你可以按这个设置，但要记住的是，即使你的机器是一个轻载的WEB服务器，也有因为大量的死套接字而内存溢出的风险，FIN- WAIT-2的危险性比FIN-WAIT-1要小，因为它最多只能吃掉1.5K内存，但是它们的生存期长些。 DOS和DDOS原理假冒的IP发来海量的请求连接的第一个握手包（SYN包），被攻击服务器回应第二个握手包（SYN+ACK包），因为对方是假冒IP，对方永远收不到包且不会回应第三个握手包。导致被攻击服务器保持大量SYN_RECV状态的“半连接” 应急处理netstat -na&gt;net.lognetstat -na |grep SYN_RECV|moreiptables -A INPUT -s 173.0.0.0/8 -p tcp –dport 80 -j DROP 使用F5挡攻击,中转一层让客户端先和F5三次握手，连接建立之后F5才转发到后端业务服务器 调整系统参数挡攻击tcp_synack_retries = 0不重试，默认重试5次net.ipv4.tcp_max_syn_backlog = 200000 sysctl -p]]></content>
      <categories>
        <category>Linux</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[JVM调优]]></title>
    <url>%2F2018%2F11%2F20%2FJVM%2FJVM%E8%B0%83%E4%BC%98%2F</url>
    <content type="text"><![CDATA[JVM调优基础知识： 基本数据类型，堆对象的引用，程序存储在栈中，方法以先进后出进栈，栈的起点是main方法一个线程对应一个栈空间，栈是运行单元，栈调优参数：-Xss，StackOverFlowError是栈中死循环无法返回递归。 对象存储在堆中，堆是存储单元。堆调优参数：-Xms 垃圾回收算法 引用计数：增加一个对象引用，计数加1，减少一个对象引用，计数减1，计数为0 回收，问题：循环引用无法回收 标记-清除：第一阶段从根节点开始标记对象引用，第二阶段未标记的对象清除。问题：空间碎片 复制：两块内存，复制正在使用对象到另外一块内存空间。问题：两倍空间 标记-整理：第一阶段从根节点开始标记对象引用，第二阶段未标记的对象清除同时整理存活对象到清除的对象空间上 分代回收不同对象有不同的生命周期（人也如此），session，socket等需要长周期，String 这种不变类需要短周期 分代： 年轻代（Eden，survivor），有意思的命名！Eden：伊甸园，亚当夏娃居住地。survivor：幸存者 年老代， 持久代（方法区），java.lang.OutOfMemoryError: PermGen space，调优参数：-XX:MaxPermSize。调优经验：问题描述：thrift定义了大量big class，尽管以及做了生产环境1024M的调优，但依旧出现PerGen space错误。解决办法：升级到jdk8。原理：因为jdk8已经元空间代替持久代，metaspace占用本地内存，不占用虚拟机内存。 GC类型 scavenge（搜索） GC：主要作用于年轻代，高频清理Eden，采用并行收集器，调优参数：XX:+UseParallelGC full GC 配置参数 -Xmx：JVM最大可用内存 -Xms：JVM初始内存，设置与-Xmx相同，以避免每次垃圾回收完成后JVM重新分配内存 -Xmn：年轻代内存 -Xss：]]></content>
      <categories>
        <category>Java</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[k8s集群部署]]></title>
    <url>%2F2018%2F10%2F11%2Fk8s%2Fk8s%E9%9B%86%E7%BE%A4%E9%83%A8%E7%BD%B2%2F</url>
    <content type="text"><![CDATA[k8s集群部署master准备阶段hostnamectl –static set-hostname mastervi /etc/hostsapt-get updateapt-get install firewalld -ysystemctl stop firewalldapt install selinux-utils -ysetenforce 0swapoff -a vi /etc/sysctl.conf1net.ipv4.ip_forward = 1 sysctl -p vi /etc/docker/daemon.json123456789101112131415161718192021222324252627&#123; &quot;iptables&quot;: false&#125;```linuxsudo tee /etc/sysctl.d/k8s.conf &lt;&lt;-&apos;EOF&apos;net.bridge.bridge-nf-call-ip6tables = 1net.bridge.bridge-nf-call-iptables = 1EOFsudo sysctl --system### docker 安装```docker# 安装包允许apt通过HTTPS使用仓库1. apt-get install -y apt-transport-https ca-certificates curl software-properties-common# 添加Docker官方GPG key2. curl -fsSL https://download.docker.com/linux/ubuntu/gpg | apt-key add -# 设置Docker稳定版仓库3. add-apt-repository &quot;deb [arch=amd64] https://download.docker.com/linux/ubuntu $(lsb_release -cs) stable&quot;4. add-apt-repository &quot;deb https://mirrors.aliyun.com/kubernetes/apt kubernetes-xenial main&quot;5. apt-get update# 安装Docker CE（社区版）6. apt-get install -y docker-ce=17.03.2~ce-0~ubuntu-xenial 安装kubeadm1apt-get install -y kubelet=1.10.3-00 kubeadm=1.10.3-00 kubectl=1.10.3-00 --allow-unauthenticated 12apt-cache madison kubeadmapt-get remove -y kubelet kubeadm kubectl kubeadm初始化集群国内镜像1234567#!/bin/bashimages=(kube-proxy-amd64:v1.10.3 kube-scheduler-amd64:v1.10.3 kube-controller-manager-amd64:v1.10.3 kube-apiserver-amd64:v1.10.3 etcd-amd64:3.1.12 pause-amd64:3.1 k8s-dns-sidecar-amd64:1.14.8 k8s-dns-kube-dns-amd64:1.14.8 k8s-dns-dnsmasq-nanny-amd64:1.14.8)for imageName in $&#123;images[@]&#125; ; do docker pull anjia0532/$imageName docker tag anjia0532/$imageName k8s.gcr.io/$imageName docker rmi anjia0532/$imageNamedone 123创建/etc/sysctl.d/k8s.conf文件，添加如下内容：net.bridge.bridge-nf-call-ip6tables = 1net.bridge.bridge-nf-call-iptables = 1 初始化集群1kubeadm init --kubernetes-version 1.10.3 --apiserver-advertise-address=172.xx.xxx.xx --pod-network-cidr=10.244.0.0/16 123mkdir -p $HOME/.kubesudo cp -i /etc/kubernetes/admin.conf $HOME/.kube/configsudo chown $(id -u):$(id -g) $HOME/.kube/config 生成如下串，请记录下来1kubeadm join 172.xx.xxx.xx:6443 --token xxxxxx --discovery-token-ca-cert-hash sha256:xxxxxxxxxxxxx 1234kubectl get nodekubectl get pod --all-namespaceskubectl create -f https://raw.githubusercontent.com/coreos/flannel/master/Documentation/kube-flannel-rbac.ymlkubectl apply -f https://raw.githubusercontent.com/coreos/flannel/master/Documentation/kube-flannel.yml 123heapsterkubectl create -f http://res.yinnote.com/kubernetes/heapster/1.5.1/heapster-rbac.yamlkubectl create -f http://res.yinnote.com/kubernetes/heapster/1.5.1/influxdb/heapster.yaml kubernetes-dashboard安装1234567891011121314151617181920212223# 下载镜像docker pull siriuszg/kubernetes-dashboard-amd64docker tag siriuszg/kubernetes-dashboard-amd64 k8s.gcr.io/kubernetes-dashboard-amd64:v1.10.0wget https://raw.githubusercontent.com/kubernetes/dashboard/master/src/deploy/recommended/kubernetes-dashboard.yamlvi kubernetes-dashboard.yaml修改：type:NodePort# 生成client-certificate-datagrep 'client-certificate-data' ~/.kube/config | head -n 1 | awk '&#123;print $2&#125;' | base64 -d &gt;&gt; kubecfg.crt# 生成client-key-datagrep 'client-key-data' ~/.kube/config | head -n 1 | awk '&#123;print $2&#125;' | base64 -d &gt;&gt; kubecfg.key# 生成p12openssl pkcs12 -export -clcerts -inkey kubecfg.key -in kubecfg.crt -out kubecfg.p12 -name "kubernetes-client"https://192.168.x.xxx:6443/api/v1/namespaces/kube-system/services/https:kubernetes-dashboard:/proxykubectl describe secret admin-user --namespace=kube-system node1将Node加到集群中123456789#!/bin/bashimages=(kube-proxy-amd64:v1.10.3 kube-scheduler-amd64:v1.10.3 kube-controller-manager-amd64:v1.10.3 kube-apiserver-amd64:v1.10.3 etcd-amd64:3.1.12 pause-amd64:3.1 k8s-dns-sidecar-amd64:1.14.8 k8s-dns-kube-dns-amd64:1.14.8 k8s-dns-dnsmasq-nanny-amd64:1.14.8)for imageName in $&#123;images[@]&#125; ; do docker pull anjia0532/$imageName docker tag anjia0532/$imageName k8s.gcr.io/$imageName docker rmi anjia0532/$imageNamedonekubeadm join 172.xx.xxx.xxx:6443 --token xxxxx --discovery-token-ca-cert-hash sha256:xxxxxxxxx kubectl 自动补全1source &lt;(kubectl completion bash) 卸载集群想要撤销kubeadm做的事，首先要排除节点，并确保在关闭节点之前要清空节点。 在主节点上运行：12kubectl drain &lt;node name&gt; --delete-local-data --force --ignore-daemonsetskubectl delete node &lt;node name&gt; --grace-period=0 --force 然后在需要移除的节点上，重置kubeadm的安装状态：1kubeadm reset 如果你想重新配置集群，只需运行kubeadm init或者kubeadm join并使用所需的参数即可。 卸载cni123456789101112kubeadm resetsystemctl stop kubeletsystemctl stop dockerrm -rf /var/lib/cni/rm -rf /var/lib/kubelet/*rm -rf /etc/cni/ifconfig cni0 downifconfig flannel.1 downifconfig docker0 downip link delete cni0ip link delete flannel.1systemctl start docker Troubleshooting1journalctl -u kubelet]]></content>
      <categories>
        <category>k8s</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[查看CPU，内存，硬盘]]></title>
    <url>%2F2018%2F02%2F28%2Flinux%2FLinux%E6%9F%A5%E7%9C%8BCPU%EF%BC%8C%E5%86%85%E5%AD%98%EF%BC%8C%E7%A1%AC%E7%9B%98%2F</url>
    <content type="text"><![CDATA[Linux查看CPU，内存，硬盘查看CPU查看CPU核数12# cat /proc/cpuinfo | grep &quot;cpu cores&quot; | uniqcpu cores : 4 查看CPU个数12# cat /proc/cpuinfo | grep &quot;physical id&quot; | uniq | wc -l2 **uniq命令：删除重复行;wc –l命令：统计行数** 查看CPU型号12# cat /proc/cpuinfo | grep &apos;model name&apos; |uniqmodel name : Intel(R) Xeon(R) CPU E5630 @ 2.53GHz 总结：该服务器有2个4核CPU，型号Intel(R) Xeon(R) CPU E5630 @ 2.53GHz 查看内存查看内存总数12#cat /proc/meminfo | grep MemTotalMemTotal: 32941268 kB //内存32G 查看内存条数1# dmidecode |grep -A16 &quot;Memory Device$&quot; 总结：该服务器有两条2G内存 ，空余4个插槽 查看硬盘查看硬盘大小12# fdisk -l | grep DiskDisk /dev/cciss/c0d0: 146.7 GB, 146778685440 bytes 总结：硬盘大小146.7G，即厂商标称的160G 同步系统时间12yum install -y ntpdate ntpdate time.nuri.net 123456time.nist.govtime.nuri.net0.asia.pool.ntp.org1.asia.pool.ntp.org2.asia.pool.ntp.org3.asia.pool.ntp.org 1hwclock -w 12#date#hwclock 12345定时执行时间同步任务，所以我们利用crontab -e 来添加定时任务#* */1 * * * root ntpdate time.nuri.net;hwclock -w 即：每隔一个小时同步一下internet时间。 TCP状态查看：1netstat -n | grep 60.214.137.170 查看公网IP：1ip addr show eth0 | grep inet | awk &apos;&#123; print $2; &#125;&apos; | sed &apos;s/\/.*$//&apos; 查看系统：1lsb_release -a 1cat /proc/version 查看yum安装创建相关文件：12rpm -qa|grep redis rpm -ql redis 挂载硬盘12umount /dev/vdb1fuser -mv /home uname -aLinux（系统名） iZ23jnmf7iwZ（节点名称） 2.6.32-431.23.3.el6.x86_64（操作系统的发行版号） #1 SMP Thu Jul 31 17:20:51 UTC 2014（内核版本） x86_64（硬件平台） x86_64（机器硬件名） x86_64（系统处理器的体系结构） GNU/Linux（操作系统） 查看外网ip1curl members.3322.org/dyndns/getip]]></content>
      <categories>
        <category>Linux</category>
      </categories>
  </entry>
</search>
